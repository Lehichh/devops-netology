# devops-netology
**Sarkisyan Aleksey**

**Домашнее задание - 6.6. Troubleshooting`**


**Задание 1**

Возвращается информация обо всех активных операциях БД db1, которые вополняются дольше 180 секунд.

```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```

Завершает операцию в соответствии с идентификатором операции.

```
db.killOp(opid)
```

Вообще нужно сперва разобраться почему запросы выполняются долго и учитывать сам объем данных.

Удостовериться что БД на SSD дисках и что БД индексирована.

Так же можно задать ограничение на время выполнения запроса, пример из документации:

```
db.location.find( { "town": { "$regex": "(Pine Lumber)",
                              "$options": 'i' } } ).maxTimeMS(30)
```


**Задание 2**

Однако алгоритм является адаптивным и зациклится, если обнаружит, что более 25% ключей уже просрочены в наборе выбранных ключей. Но, учитывая, что мы запускаем алгоритм десять раз в секунду, это означает, что срок действия более чем 25% ключей в нашей случайной выборке истекает как минимум в одну и ту же секунду .

В основном это означает, что если в базе данных есть много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия , Redis может заблокировать, чтобы получить процент ключей, срок действия которых истек ниже, чем 25%.

Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек, и обычно абсолютно безвреден, так как странно, что срок действия большого количества ключей истекает в одну и ту же секунду, но не исключено, что пользователь EXPIREATшироко используется с тем же временем Unix.


**Задание 3**

Эта ошибка появляется, когда время ожидания соединения между вашим клиентом MySQL и сервером базы данных истекает. По сути, запрос возвращал данные слишком долго, поэтому соединение разрывалось.

Документация MySQL предлагает увеличить значения net_read_timeoutили connect_timeoutна сервере, либо увеличить значения времени ожидания клиента MySQL к серверу.



**Задание 4**


Out-Of-Memory Killer - это процесс, вызывается для спасения ядра ОС от сбоя. Завершая процесс, который съедает память.

Когда заканчивается память, вызывается функция out_of_memory(). В ней есть функция select_bad_process(), которая получает оценку от функции badness().

Если мы хотим совсем избежать завершения процесса, то нам нужно присвоить отрицательное значение параметру ядра oom_score_adj того процессв, который нам важен.

источник https://habr.com/ru/company/southbridge/blog/464245/