# devops-netology
**Sarkisyan Aleksey

**Выполнение задания 3.1 Работа в терминале

**1.
**cd** - внутренняя команда, ее нет в файловой системе. Работает только для оболочки, в которой выполняется.

**2.
утилита **wc** с параметром **-l** вернет количество строк, но у **grep** есть свой параметр **-с**
**grep -c <some_string> <some_file>

**3.
**systemd

**4.
Напишем заведомо ошибочную команду **ls
**ls -1234 2> /dev/pts/2

**5.
**cat 0< test.txt 1> test2.txt
В результате создался файл **test2.txt** со строкой которая уже есть в **test.txt

**6.
Перенаправить сможем, но чтобы увидеть необходимо нажимать клавиши Ctrl + Alt + F1..F6

**7.
**Bash 5>&1** - создаст дескриптор 5 и перенаправит его(дескриптор) в **stdout
**echo netology > /proc/$$/fd/5** - выведет дескриптор **5** перенаправленный в **stdout

**8.
**date -c 5>&2 2>&1 1>&5 |grep p -c

**9.
Показывает переменные среды для текущего процесса, можно так же получить командой **env** и будет наглядно.

**10.
**/proc/<PID>/cmdline** - только для чтения файл, содержит полны путь до файла процесса.
**/proc/<PID>/exe** - представляет собой символическую ссылку, содержащую фактический путь к исполняемой команде. 
попытка открыть его откроет исполняемый файл.

**11.
Введ **cat /proc/cpuinfo | grep sse
версия **4.2 

**12.
Я думаю это происходит из-за того что мы запускаем команду будучи уже внутри терминала.
То есть мы уже открыли оболочку, которая работает внутри терминала, а команда **ssh localhost 'tty'**
не работает внутри терминала.

**13.
Взял с интернета написанный на Phyton скрипт, который считает секунды, запустил его и через пару выводов прервал **Ctrl + Z
Далее запустил **Screen**, узнал процесс **jobs -l** и выолнил команду **reptyr PID

**14.
tee - работает как тройник, передает так же данные и в **stdout
во второй конструкции кода команда запускается под **sudo** и может записать файл.


